package vn.edu.iuh.fit.service.implement;import org.checkerframework.checker.fenum.qual.SwingVerticalOrientation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.*;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Service;import vn.edu.iuh.fit.dto.MonthlyReviewStatistics;import vn.edu.iuh.fit.dto.TourReviewStatistics;import vn.edu.iuh.fit.dto.UserReviewStatistics;import vn.edu.iuh.fit.dto.request.ReviewRequest;import vn.edu.iuh.fit.dto.respone.ReviewResponseDTO;import vn.edu.iuh.fit.entity.Review;import vn.edu.iuh.fit.entity.Tour;import vn.edu.iuh.fit.entity.User;import vn.edu.iuh.fit.repositories.ReviewRepository;import vn.edu.iuh.fit.repositories.TourRepository;import vn.edu.iuh.fit.repositories.UserRepository;import vn.edu.iuh.fit.service.ReviewService;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.ZoneId;import java.time.format.DateTimeFormatter;import java.util.ArrayList;import java.util.Comparator;import java.util.List;import java.util.Map;import java.util.stream.Collectors;@Servicepublicclass ReviewServiceImpl extends AbstractCrudService<Review, Long> implements ReviewService {    @Autowired    private ReviewRepository reviewRepository;    @Autowired     private TourRepository tourRepository;    @Autowired    private UserRepository userRepository;    @Override    protected JpaRepository<Review, Long> getRepository() {        return reviewRepository;    }    @Override    public List<TourReviewStatistics> getAllTourReviewStatistics() {        List<Tour> tours = tourRepository.findAll();        List<TourReviewStatistics> statisticsList = new ArrayList<>();        for (Tour tour : tours) {            List<Review> reviews = reviewRepository.findReviewByTour(tour);            TourReviewStatistics statistics = new TourReviewStatistics();            statistics.setTourId(tour.getTourId());            statistics.setTourName(tour.getTourName());            statistics.setTotalReviews(reviews.size());            if (reviews.isEmpty()) {                statistics.setAverageRating(0);                statistics.setRatingDistribution(new int[5]);            } else {                double totalRating = 0;                int[] distribution = new int[5];                for (Review review : reviews) {                    totalRating += review.getRating();                    distribution[review.getRating() - 1]++;                }                statistics.setAverageRating(totalRating / reviews.size());                statistics.setRatingDistribution(distribution);            }            statisticsList.add(statistics);        }        return statisticsList;    }    @Override    public List<MonthlyReviewStatistics> getMonthlyReviewStatistics() {        List<Review> reviews = reviewRepository.findAll();        // Nhóm đánh giá theo tháng        Map<String, List<Review>> reviewsByMonth = reviews.stream()                .collect(Collectors.groupingBy(review -> {                    LocalDate date = review.getReviewDate().toLocalDate();                    return date.format(DateTimeFormatter.ofPattern("yyyy-MM")); // Định dạng tháng                }));        List<MonthlyReviewStatistics> statisticsList = new ArrayList<>();        for (Map.Entry<String, List<Review>> entry : reviewsByMonth.entrySet()) {            String monthKey = entry.getKey();            List<Review> monthlyReviews = entry.getValue();            int totalReviews = monthlyReviews.size();            double averageRating = monthlyReviews.stream()                    .mapToInt(Review::getRating)                    .average()                    .orElse(0.0);            MonthlyReviewStatistics statistics = new MonthlyReviewStatistics();            statistics.setMonth(convertMonth(monthKey)); // Chuyển đổi tháng            statistics.setTotalReviews(totalReviews);            statistics.setAverageRating(averageRating);            statisticsList.add(statistics);        }        // Sắp xếp danh sách theo tháng từ 1 đến 12        statisticsList.sort(Comparator.comparingInt(stat -> Integer.parseInt(stat.getMonth().split(" ")[1])));        return statisticsList;    }    // Phương thức chuyển đổi tháng    private String convertMonth(String monthKey) {        String[] parts = monthKey.split("-");        int month = Integer.parseInt(parts[1]); // Lấy tháng từ định dạng yyyy-MM        return "Tháng " + month; // Trả về định dạng "Tháng X"    }    @Override    public List<UserReviewStatistics> getUserReviewStatistics() {        List<UserReviewStatistics> userStatisticsList = new ArrayList<>();        List<User> users = userRepository.findAll();        for (User user : users) {            List<Review> reviews = reviewRepository.findReviewByUser(user);            UserReviewStatistics statistics = new UserReviewStatistics();            statistics.setFullName(user.getFullName());            statistics.setTotalReviews(reviews.size());            List<UserReviewStatistics.ReviewSummary> reviewSummaries = reviews.stream()                    .map(review -> new UserReviewStatistics.ReviewSummary(                            review.getReviewId(),                            review.getComment(),                            review.getRating(),                            review.getReviewDate()))                    .collect(Collectors.toList());            statistics.setReviews(reviewSummaries);            userStatisticsList.add(statistics);        }        return userStatisticsList;    }    @Override    public ReviewResponseDTO addReview(ReviewRequest reviewRequest) {        User user = userRepository.findById(reviewRequest.getUserId()).orElse(null);        Tour tour = tourRepository.findById(reviewRequest.getTourId()).orElse(null);        if (user == null || tour == null) {            throw new IllegalArgumentException("User or Tour not found");        }        Review review = new Review();        review.setUser(user);        review.setTour(tour);        review.setRating(reviewRequest.getRating());        review.setComment(reviewRequest.getComment());        review.setReviewDate(LocalDateTime.now(ZoneId.of("Asia/Bangkok")));        review.setActive(true);        Review savedReview = reviewRepository.save(review);        ReviewResponseDTO reviewDTO = new ReviewResponseDTO();        reviewDTO.setReviewId(savedReview.getReviewId());        reviewDTO.setUserId(user.getUserId());        reviewDTO.setTourId(tour.getTourId());        reviewDTO.setRating(savedReview.getRating());        reviewDTO.setComment(savedReview.getComment());        reviewDTO.setReviewDate(savedReview.getReviewDate());        reviewDTO.setActive(savedReview.isActive());        return reviewDTO;    }    @Override    public ReviewResponseDTO updateReview(ReviewRequest reviewRequest, Long id) {        Review existingReview = reviewRepository.findById(id).orElse(null);        if (existingReview == null) {            throw new IllegalArgumentException("Review not found");        }        existingReview.setRating(reviewRequest.getRating());        existingReview.setComment(reviewRequest.getComment());        existingReview.setReviewDate(LocalDateTime.now(ZoneId.of("Asia/Bangkok")));        existingReview.setActive(true);        Review updatedReview = reviewRepository.save(existingReview);        ReviewResponseDTO reviewResponseDTO = new ReviewResponseDTO();        reviewResponseDTO.setReviewId(updatedReview.getReviewId());        reviewResponseDTO.setUserId(updatedReview.getUser().getUserId());        reviewResponseDTO.setTourId(updatedReview.getTour().getTourId());        reviewResponseDTO.setRating(updatedReview.getRating());        reviewResponseDTO.setComment(updatedReview.getComment());        reviewResponseDTO.setReviewDate(updatedReview.getReviewDate());         reviewResponseDTO.setActive(updatedReview.isActive());        return reviewResponseDTO;    }    @Override    public ReviewResponseDTO getReviewById(Long id) {        Review review = reviewRepository.findById(id).orElse(null);        if (review == null) {            return null;        }        ReviewResponseDTO reviewResponseDTO = new ReviewResponseDTO();        reviewResponseDTO.setReviewId(review.getReviewId());        reviewResponseDTO.setUserId(review.getUser().getUserId());        reviewResponseDTO.setTourId(review.getTour().getTourId());        reviewResponseDTO.setRating(review.getRating());        reviewResponseDTO.setComment(review.getComment());        reviewResponseDTO.setReviewDate(review.getReviewDate());        return reviewResponseDTO;    }    @Override    public void deleteReview(Long id) {        if (!reviewRepository.existsById(id)) {            throw new IllegalArgumentException("Review not found");        }        reviewRepository.deleteById(id);    }//    public Page<Review> getAllReviews(Pageable pageable) {//        Pageable sortedPageable = PageRequest.of(//                pageable.getPageNumber(),//                pageable.getPageSize(),//                Sort.by(Sort.Direction.DESC, "reviewDate")//        );//        return reviewRepository.findAll(sortedPageable);//    }public Page<Review> getReviews(int page, int size, String keyword, Integer rating,                               LocalDate startDate, LocalDate endDate,                               Boolean active) {    List<Review> allReviews = reviewRepository.findAll();    // Chuyển đổi LocalDate thành LocalDateTime    LocalDateTime startDateTime = (startDate != null) ? startDate.atStartOfDay() : null;    LocalDateTime endDateTime = (endDate != null) ? endDate.atTime(23, 59, 59) : null;    List<Review> filteredReviews = allReviews.stream()            .filter(review -> (keyword == null || review.getUser().getFullName().toLowerCase().contains(keyword.toLowerCase())) &&                    (rating == null || review.getRating().equals(rating)) &&                    (startDateTime == null || review.getReviewDate().isAfter(startDateTime.minusNanos(1))) && // Bao gồm ngày bắt đầu                    (endDateTime == null || review.getReviewDate().isBefore(endDateTime.plusNanos(1))) && // Bao gồm ngày kết thúc                    (active == null || review.isActive() == active))            .sorted(Comparator.comparing(Review::getReviewDate).reversed())            .collect(Collectors.toList());    long totalFilteredElements = filteredReviews.size();    int start = Math.min(page * size, (int) totalFilteredElements);    int end = Math.min(start + size, (int) totalFilteredElements);    List<Review> paginatedReviews = filteredReviews.subList(start, end);    return new PageImpl<>(paginatedReviews, PageRequest.of(page, size), totalFilteredElements);}    @Override    public Review updateReviewStatus(long reviewId, boolean isActive) {        Review review = reviewRepository.findById(reviewId)                .orElseThrow(() -> new IllegalArgumentException("Review không tồn tại với ID: " + reviewId));        review.setActive(isActive);        return reviewRepository.save(review);    }}