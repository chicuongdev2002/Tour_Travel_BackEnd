package vn.edu.iuh.fit.service.implement;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.domain.Specification;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import vn.edu.iuh.fit.dto.*;import vn.edu.iuh.fit.entity.*;import vn.edu.iuh.fit.enums.AccountRole;import vn.edu.iuh.fit.exception.*;import vn.edu.iuh.fit.repositories.AccountRepository;import vn.edu.iuh.fit.repositories.PaymentRepository;import vn.edu.iuh.fit.repositories.UserRepository;import vn.edu.iuh.fit.service.AccountService;import java.util.List;import java.util.Optional;import java.util.stream.Collectors;@Servicepublic class AccountServiceImpl extends AbstractCrudService<Account, Long> implements AccountService {    @Autowired    private AccountRepository accountRepository;    @Autowired    private UserRepository userRepository;    @Autowired    private PaymentRepository paymentRepository;    @Autowired    private PasswordEncoder passwordEncoder; // Để mã hóa mật khẩu    @Override    protected JpaRepository<Account, Long> getRepository() {        return accountRepository;    }   public User register(UserRegistrationDTO registrationDTO) {    // Check if the account already exists    System.out.println("registrationDTO: " + registrationDTO);    Optional<Account> existingAccount = accountRepository.findByUsername(registrationDTO.getUsername());    System.out.println("existingAccount: " + existingAccount);    if (existingAccount.isPresent()) {        throw new AccountAlreadyExistsException("Tài khoản đã tồn tại");    }    // Check if the email already exists    Optional<User> existingUser = userRepository.findByEmail(registrationDTO.getEmail());    System.out.println("existingUser: " + existingUser);    if (existingUser.isPresent()) {        throw new EmailAlreadyExistsException("Email đã được sử dụng");    }    // Create a new user    User newUser = new User();    newUser.setEmail(registrationDTO.getEmail());    newUser.setFullName(registrationDTO.getFullName());    newUser.setPhoneNumber(registrationDTO.getPhoneNumber());    // Save the user to the database    userRepository.save(newUser);    // Create a new account    Account newAccount = new Account();    newAccount.setUsername(registrationDTO.getUsername());    newAccount.setPassword(passwordEncoder.encode(registrationDTO.getPassword())); // Encode password    newAccount.setRole(AccountRole.CUSTOMER);    newAccount.setActive(true);    newAccount.setUser(newUser); // Associate User with Account    // Save the account to the database    accountRepository.save(newAccount);    return newUser; // Return the new user}    @Override    public UserInfoDTO login(String username, String password) {        // Find account by username        Optional<Account> accountOpt = accountRepository.findByUsername(username);        // Check if account exists        if (accountOpt.isEmpty()) {            throw new AccountNotFoundException("Tài khoản không tồn tại.");        }        Account account = accountOpt.get();        // Check password        if (!passwordEncoder.matches(password, account.getPassword())) {            throw new InvalidPasswordException("Mật khẩu không đúng.");        }        User user = account.getUser();        UserInfoDTO userDTO = new UserInfoDTO();        userDTO.setUserId(user.getUserId());        userDTO.setEmail(user.getEmail());        userDTO.setFullName(user.getFullName());        userDTO.setPhoneNumber(user.getPhoneNumber());        // Map addresses        if (user.getAddresses() != null) {            List<AddressDTO> addressDTOs = user.getAddresses().stream()                    .map(address -> {                        AddressDTO addressDTO = new AddressDTO();                        addressDTO.setAddressId(address.getAddressId());                        addressDTO.setAddress(address.getAddress());                        return addressDTO;                    })                    .collect(Collectors.toList());            userDTO.setAddresses(addressDTOs);        }//        // Map reviews//        if (user.getReviews() != null) {//            List<ReviewDTO> reviewDTOs = user.getReviews().stream()//                    .map(review -> {//                        ReviewDTO reviewDTO = new ReviewDTO();//                        reviewDTO.setReviewId(review.getReviewId());//                        reviewDTO.setRating(review.getRating());//                        reviewDTO.setComment(review.getComment());//                        reviewDTO.setReviewDate(review.getReviewDate());//                        return reviewDTO;//                    })//                    .collect(Collectors.toList());//            userDTO.setReviews(reviewDTOs);//        }////        // Map bookings with tour, departure, pricing, and payment information//        if (user.getBookings() != null) {//            List<BookingDTO> bookingDTOs = user.getBookings().stream()//                    .map(booking -> {//                        BookingDTO bookingDTO = new BookingDTO();//                        bookingDTO.setBookingId(booking.getBookingId());//                        bookingDTO.setBookingDate(booking.getBookingDate());//                        bookingDTO.setParticipants(booking.getParticipants());//                        bookingDTO.setActive(booking.isActive());////                        // Map departure information//                        Departure departure = booking.getDeparture();//                        if (departure != null) {//                            DepartureDTO departureDTO = new DepartureDTO();//                            departureDTO.setDepartureId(departure.getDepartureId());//                            departureDTO.setStartDate(departure.getStartDate());//                            departureDTO.setEndDate(departure.getEndDate());////                            // Map tour pricing information//                            if (departure.getTourPricing() != null) {//                                List<TourPricingDTO> pricingDTOs = departure.getTourPricing().stream()//                                        .map(pricing -> new TourPricingDTO(//                                                pricing.getPrice(),//                                                pricing.getParticipantType(),//                                                pricing.getModifiedDate()))//                                        .collect(Collectors.toList());//                                departureDTO.setTourPricing(pricingDTOs);//                            }//                            bookingDTO.setDeparture(departureDTO);////                            // Map tour information//                            Tour tour = departure.getTour();//                            if (tour != null) {//                                TourInfoDTO tourDTO = new TourInfoDTO(//                                        tour.getTourId(),//                                        tour.getTourName(),//                                        tour.getTourDescription(),//                                        tour.getDuration(),//                                        tour.getStartLocation(),//                                        tour.getTourType()//                                );//                                bookingDTO.setTour(tourDTO);//                            }//                        }//                        List<Payment> payments = paymentRepository.findByBooking_BookingId(booking.getBookingId());//                        if (payments != null) {//                            List<PaymentInfoDTO> paymentDTOs = payments.stream()//                                    .map(payment -> new PaymentInfoDTO(//                                            payment.getPaymentId(),//                                            payment.getAmount(),//                                            payment.getPaymentDate(),//                                            payment.getPaymentMethod()))//                                    .collect(Collectors.toList());//                            bookingDTO.setPayments(paymentDTOs);//                        }////                        return bookingDTO;//                    })//                    .collect(Collectors.toList());//            userDTO.setBookings(bookingDTOs);//        }        return userDTO;    }    @Override    public void changePassword(long userId, String oldPassword, String newPassword) {        // Tìm tài khoản dựa trên userId        Optional<Account> optionalAccount = accountRepository.findByUserId(userId);        if (optionalAccount.isPresent()) {            Account account = optionalAccount.get();            // Kiểm tra mật khẩu cũ            if (passwordEncoder.matches(oldPassword, account.getPassword())) {                // Nếu mật khẩu cũ trùng khớp, thay đổi mật khẩu mới                account.setPassword(passwordEncoder.encode(newPassword));                accountRepository.save(account);            } else {                throw new RuntimeException("Mật khẩu cũ không đúng");            }        } else {            throw new RuntimeException("Tài khoản không tồn tại");        }    }    @Override    public void resetPassword(String email, String newPassword) {        System.out.println(email);        System.out.println(newPassword);        // Tìm người dùng dựa trên email        Optional<User> userOptional = userRepository.findByEmail(email);        System.out.println("userOptional" + userOptional);        if (userOptional.isPresent()) {            User user = userOptional.get();            // Tìm tài khoản liên quan đến người dùng            Optional<Account> accountOptional = accountRepository.findByUser_UserId(user.getUserId());            System.out.println("accountOptional" + accountOptional);            if (accountOptional.isPresent()) {                Account account = accountOptional.get();                account.setPassword(passwordEncoder.encode(newPassword)); // Mã hóa mật khẩu mới                accountRepository.save(account); // Lưu tài khoản với mật khẩu mới                System.out.println("account" + account);            } else {                throw new RuntimeException("Tài khoản không tồn tại cho người dùng này");            }        } else {            throw new RuntimeException("Tài khoản không tồn tại với email này");        }    }    @Override    public boolean existsByUsername(String username) {        System.out.println("username " + username);        return accountRepository.findByUsername(username).isPresent();    }    @Override    public String getEmailByUsername(String username) {        Optional<Account> account = accountRepository.findByUsername(username);        if (account != null && account.get().getUser() != null) {            return account.get().getUser().getEmail();        }        return null;    }    public AccountDTO mapToDTO(Account account) {        if (account == null) {            return null;        }        AccountDTO dto = new AccountDTO();        dto.setUserId(account.getUser().getUserId());        dto.setUsername(account.getUsername());        dto.setPassword(account.getPassword());        dto.setRole(account.getRole());        dto.setActive(account.isActive());        dto.setFullName(account.getUser().getFullName());        return dto;    }    public List<AccountDTO> getAllAccountDTOs() {        List<Account> accounts = accountRepository.findAll();        return accounts.stream()                .map(this::mapToDTO)                .collect(Collectors.toList());    }    public Page<AccountDTO> getAllAccounts(int page, int size, String role, String status) {        Pageable pageable = PageRequest.of(page, size);        Specification<Account> spec = Specification.where(null);        if (role != null && !role.isEmpty()) {            spec = spec.and((root, query, criteriaBuilder) ->                    criteriaBuilder.equal(root.get("role"), role)            );        }        if ("active".equalsIgnoreCase(status)) {            spec = spec.and((root, query, criteriaBuilder) ->                    criteriaBuilder.isTrue(root.get("isActive"))            );        } else if ("locked".equalsIgnoreCase(status)) {            spec = spec.and((root, query, criteriaBuilder) ->                    criteriaBuilder.isFalse(root.get("isActive"))            );        }        Page<Account> accountPage = accountRepository.findAll(spec, pageable);        return accountPage.map(this::mapToDTO);    }    public void upgradeAccount(long userId, AccountRole newRole) {        Optional<Account> optionalAccount = accountRepository.findByUserId(userId);        if (optionalAccount.isPresent()) {            Account account = optionalAccount.get();            account.setRole(newRole);            accountRepository.save(account);        } else {            throw new RuntimeException("Account not found");        }    }    public void lockAccount(long userId) {        Optional<Account> optionalAccount = accountRepository.findByUserId(userId);        if (optionalAccount.isPresent()) {            Account account = optionalAccount.get();            account.setActive(false);            accountRepository.save(account);        } else {            throw new RuntimeException("Account not found");        }    }    public void unlockAccount(long userId) {        Optional<Account> optionalAccount = accountRepository.findByUserId(userId);        if (optionalAccount.isPresent()) {            Account account = optionalAccount.get();            account.setActive(true);            accountRepository.save(account);        } else {            throw new RuntimeException("Account not found");        }    }}