package vn.edu.iuh.fit.service.implement;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.domain.Specification;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import vn.edu.iuh.fit.dto.*;import vn.edu.iuh.fit.entity.*;import vn.edu.iuh.fit.enums.AccountRole;import vn.edu.iuh.fit.exception.*;import vn.edu.iuh.fit.mailservice.EmailService;import vn.edu.iuh.fit.repositories.AccountRepository;import vn.edu.iuh.fit.repositories.PaymentRepository;import vn.edu.iuh.fit.repositories.UserRepository;import vn.edu.iuh.fit.service.AccountService;import java.security.SecureRandom;import java.util.List;import java.util.Optional;import java.util.stream.Collectors;@Servicepublic class AccountServiceImpl extends AbstractCrudService<Account, Long> implements AccountService {    @Autowired    private AccountRepository accountRepository;    @Autowired    private UserRepository userRepository;    @Autowired    private PaymentRepository paymentRepository;    @Autowired    private PasswordEncoder passwordEncoder;    @Autowired    private EmailService emailService;    @Override    protected JpaRepository<Account, Long> getRepository() {        return accountRepository;    }    public User register(UserRegistrationDTO registrationDTO) {        System.out.println("registrationDTO: " + registrationDTO);        Optional<Account> existingAccount = accountRepository.findByUsername(registrationDTO.getUsername());        System.out.println("existingAccount: " + existingAccount);        if (existingAccount.isPresent()) {            throw new AccountAlreadyExistsException("Tài khoản đã tồn tại");        }        Optional<User> existingUser = userRepository.findByEmail(registrationDTO.getEmail());        System.out.println("existingUser: " + existingUser);        if (existingUser.isPresent()) {            throw new EmailAlreadyExistsException("Email đã được sử dụng");        }        User newUser = new User();        newUser.setEmail(registrationDTO.getEmail());        newUser.setFullName(registrationDTO.getFullName());        newUser.setPhoneNumber(registrationDTO.getPhoneNumber());        if (registrationDTO.getAddress() != null && !registrationDTO.getAddress().isEmpty()) {            Address newAddress = new Address();            newAddress.setAddress(registrationDTO.getAddress());            newAddress.setUser(newUser);            newUser.getAddresses().add(newAddress);        }        userRepository.save(newUser);        Account newAccount = new Account();        newAccount.setUsername(registrationDTO.getUsername());        newAccount.setPassword(passwordEncoder.encode(registrationDTO.getPassword()));        AccountRole role = (registrationDTO.getRole() != null) ?                registrationDTO.getRole() : AccountRole.CUSTOMER;        newAccount.setRole(role);        newAccount.setActive(true);        newAccount.setUser(newUser);        accountRepository.save(newAccount);        return newUser;    }    @Override    public UserInfoDTO login(String username, String password) {        Optional<Account> accountOpt = accountRepository.findByUsername(username);        if (accountOpt.isEmpty()) {            throw new AccountNotFoundException("Tài khoản không tồn tại.");        }        Account account = accountOpt.get();        if (!passwordEncoder.matches(password, account.getPassword())) {            throw new InvalidPasswordException("Mật khẩu không đúng.");        }        if (!account.isActive()) {            throw new AccountLockedException("Tài khoản đã bị khóa.");        }        User user = account.getUser();        UserInfoDTO userDTO = new UserInfoDTO();        userDTO.setUserId(user.getUserId());        userDTO.setEmail(user.getEmail());        userDTO.setFullName(user.getFullName());        userDTO.setPhoneNumber(user.getPhoneNumber());        if (user.getAddresses() != null) {            List<AddressDTO> addressDTOs = user.getAddresses().stream()                    .map(address -> {                        AddressDTO addressDTO = new AddressDTO();                        addressDTO.setAddressId(address.getAddressId());                        addressDTO.setAddress(address.getAddress());                        return addressDTO;                    })                    .collect(Collectors.toList());            userDTO.setAddresses(addressDTOs);        }        userDTO.setRole(account.getRole());        return userDTO;    }    @Override    public UserInfoDTO loginWithEmail(String email) {        Optional<User> userOpt = userRepository.findByEmail(email);        if (userOpt.isEmpty()) {            throw new AccountNotFoundException("Tài khoản không tồn tại.");        }        User user = userOpt.get();        Account account = user.getAccount();        if (account == null || !account.isActive()) {            throw new AccountLockedException("Tài khoản đã bị khóa.");        }        UserInfoDTO userDTO = new UserInfoDTO();        userDTO.setUserId(user.getUserId());        userDTO.setEmail(user.getEmail());        userDTO.setFullName(user.getFullName());        userDTO.setPhoneNumber(user.getPhoneNumber());        if (user.getAddresses() != null) {            List<AddressDTO> addressDTOs = user.getAddresses().stream()                    .map(address -> {                        AddressDTO addressDTO = new AddressDTO();                        addressDTO.setAddressId(address.getAddressId());                        addressDTO.setAddress(address.getAddress());                        return addressDTO;                    })                    .collect(Collectors.toList());            userDTO.setAddresses(addressDTOs);        }        userDTO.setRole(account.getRole());        return userDTO;    }    @Override    public void changePassword(long userId, String oldPassword, String newPassword) {        // Tìm tài khoản dựa trên userId        Optional<Account> optionalAccount = accountRepository.findByUserId(userId);        if (optionalAccount.isPresent()) {            Account account = optionalAccount.get();            // Kiểm tra mật khẩu cũ            if (passwordEncoder.matches(oldPassword, account.getPassword())) {                // Nếu mật khẩu cũ trùng khớp, thay đổi mật khẩu mới                account.setPassword(passwordEncoder.encode(newPassword));                accountRepository.save(account);            } else {                throw new RuntimeException("Mật khẩu cũ không đúng");            }        } else {            throw new RuntimeException("Tài khoản không tồn tại");        }    }    @Override    public void resetPassword(String email, String newPassword) {        System.out.println(email);        System.out.println(newPassword);        // Tìm người dùng dựa trên email        Optional<User> userOptional = userRepository.findByEmail(email);        System.out.println("userOptional" + userOptional);        if (userOptional.isPresent()) {            User user = userOptional.get();            // Tìm tài khoản liên quan đến người dùng            Optional<Account> accountOptional = accountRepository.findByUser_UserId(user.getUserId());            System.out.println("accountOptional" + accountOptional);            if (accountOptional.isPresent()) {                Account account = accountOptional.get();                account.setPassword(passwordEncoder.encode(newPassword)); // Mã hóa mật khẩu mới                accountRepository.save(account); // Lưu tài khoản với mật khẩu mới                System.out.println("account" + account);            } else {                throw new RuntimeException("Tài khoản không tồn tại cho người dùng này");            }        } else {            throw new RuntimeException("Tài khoản không tồn tại với email này");        }    }    @Override    public boolean existsByUsername(String username) {        System.out.println("username " + username);        return accountRepository.findByUsername(username).isPresent();    }    @Override    public String getEmailByUsername(String username) {        Optional<Account> account = accountRepository.findByUsername(username);        if (account != null && account.get().getUser() != null) {            return account.get().getUser().getEmail();        }        return null;    }    public AccountDTO mapToDTO(Account account) {        if (account == null) {            return null;        }        AccountDTO dto = new AccountDTO();        dto.setUserId(account.getUser().getUserId());        dto.setUsername(account.getUsername());//        dto.setPassword(account.getPassword());        dto.setRole(account.getRole());        dto.setActive(account.isActive());        dto.setFullName(account.getUser().getFullName());        return dto;    }    public Page<AccountDTO> getAllAccounts(int page, int size, String role, String status) {        Pageable pageable = PageRequest.of(page, size);        Specification<Account> spec = Specification.where(null);        spec = spec.and((root, query, criteriaBuilder) ->                criteriaBuilder.notEqual(root.get("role"), AccountRole.ADMIN)        );        if (role != null && !role.isEmpty()) {            spec = spec.and((root, query, criteriaBuilder) ->                    criteriaBuilder.equal(root.get("role"), role)            );        }        if ("active".equalsIgnoreCase(status)) {            spec = spec.and((root, query, criteriaBuilder) ->                    criteriaBuilder.isTrue(root.get("isActive"))            );        } else if ("locked".equalsIgnoreCase(status)) {            spec = spec.and((root, query, criteriaBuilder) ->                    criteriaBuilder.isFalse(root.get("isActive"))            );        }        Page<Account> accountPage = accountRepository.findAll(spec, pageable);        return accountPage.map(this::mapToDTO);    }    @Override    public AccountDTO getAccountById(long accountId) {        Optional<Account> accountOptional = accountRepository.findById(accountId);        if (accountOptional.isEmpty()) {            throw new AccountNotFoundException("Tài khoản không tồn tại.");        }        Account account = accountOptional.get();        User user = account.getUser();        AccountDTO accountDTO = new AccountDTO();        accountDTO.setUserId(user.getUserId());        accountDTO.setUsername(account.getUsername());        accountDTO.setRole(account.getRole());        accountDTO.setActive(account.isActive());        accountDTO.setFullName(user.getFullName());        return accountDTO;    }    public void upgradeAccount(long userId, AccountRole newRole) {        Optional<Account> optionalAccount = accountRepository.findByUserId(userId);        if (optionalAccount.isPresent()) {            Account account = optionalAccount.get();            account.setRole(newRole);            accountRepository.save(account);        } else {            throw new RuntimeException("Account not found");        }    }    public AccountDTO updateAccount(long accountId, AccountDTO accountDTO) {        Optional<Account> accountOptional = accountRepository.findById(accountId);        if (accountOptional.isEmpty()) {            throw new AccountNotFoundException("Tài khoản không tồn tại.");        }        Account account = accountOptional.get();        User user = account.getUser();        if (accountDTO.getUsername() != null) {            account.setUsername(accountDTO.getUsername());        }        if (accountDTO.getFullName() != null) {            user.setFullName(accountDTO.getFullName());        }        if (accountDTO.getRole() != null) {            account.setRole(accountDTO.getRole());        }        account.setActive(accountDTO.isActive());        if (accountDTO.getPassword() != null) {            account.setPassword(passwordEncoder.encode(accountDTO.getPassword()));        }        userRepository.save(user);        accountRepository.save(account);        return mapToDTO(account);    }    public void lockAccount(long userId) {        Optional<Account> optionalAccount = accountRepository.findByUserId(userId);        if (optionalAccount.isPresent()) {            Account account = optionalAccount.get();            account.setActive(false);            accountRepository.save(account);            // Gửi email thông báo            String email = getEmailByUsername(account.getUsername());            if (email != null) {                emailService.sendLockUnlockNotification(email, "locked");            }        } else {            throw new RuntimeException("Account not found");        }    }    public void unlockAccount(long userId) {        Optional<Account> optionalAccount = accountRepository.findByUserId(userId);        if (optionalAccount.isPresent()) {            Account account = optionalAccount.get();            account.setActive(true);            accountRepository.save(account);            // Gửi email thông báo            String email = getEmailByUsername(account.getUsername());            if (email != null) {                emailService.sendLockUnlockNotification(email, "unlocked");            }        } else {            throw new RuntimeException("Account not found");        }    }    public String generateRandomPassword(int length) {        String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";        SecureRandom random = new SecureRandom();        StringBuilder password = new StringBuilder(length);        for (int i = 0; i < length; i++) {            int index = random.nextInt(chars.length());            password.append(chars.charAt(index));        }        return password.toString();    }    @Override    public void adminResetPassword(Long[] userIds) {        for (Long userId : userIds) {            Optional<Account> optionalAccount = accountRepository.findByUserId(userId);            if (optionalAccount.isPresent()) {                Account account = optionalAccount.get();                User user = account.getUser();                String newPassword = generateRandomPassword(12);                account.setPassword(passwordEncoder.encode(newPassword));                accountRepository.save(account);                // Gửi email thông báo                String email = getEmailByUsername(account.getUsername());                if (email != null) {                    emailService.sendResetPasswordNotification(email, newPassword);                }                // Gửi SMS nếu có số điện thoại                String phoneNumber = user.getPhoneNumber();                if (phoneNumber != null && !phoneNumber.isEmpty()) {                    try {                        // Chuyển đổi số điện thoại                        if (phoneNumber.startsWith("0")) {                            phoneNumber = "84" + phoneNumber.substring(1);                        }//                        vonageService.sendPasswordViaSMS(phoneNumber, newPassword);                    } catch (Exception e) {                        System.err.println("Failed to send SMS: " + e.getMessage());                    }                } else {                    System.err.println("Số điện thoại không tồn tại cho userId: " + userId);                }            } else {                System.err.println("Tài khoản không tồn tại cho userId: " + userId);            }        }    }}