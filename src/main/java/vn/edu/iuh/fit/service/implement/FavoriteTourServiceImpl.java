package vn.edu.iuh.fit.service.implement;import jakarta.persistence.EntityNotFoundException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import vn.edu.iuh.fit.dto.FavoriteTourDTO;import vn.edu.iuh.fit.dto.TourListDTO;import vn.edu.iuh.fit.entity.FavoriteTour;import vn.edu.iuh.fit.entity.Tour;import vn.edu.iuh.fit.entity.User;import vn.edu.iuh.fit.entity.*;import vn.edu.iuh.fit.enums.TourType;import vn.edu.iuh.fit.repositories.FavoriteTourRepository;import vn.edu.iuh.fit.repositories.TourRepository;import vn.edu.iuh.fit.repositories.UserRepository;import vn.edu.iuh.fit.service.FavoriteTourService;import java.math.BigDecimal;import java.time.LocalDateTime;import java.util.*;import java.util.stream.Collectors;@Servicepublic class FavoriteTourServiceImpl implements FavoriteTourService {    @Autowired    private FavoriteTourRepository favoriteTourRepository;    @Autowired    private UserRepository userRepository;    @Autowired    private TourRepository tourRepository;    @Override    public FavoriteTourDTO addFavoriteTour(Long userId, Long tourId) {        User user = userRepository.findById(userId)                .orElseThrow(() -> new IllegalArgumentException("User not found with ID: " + userId));        Tour tour = tourRepository.findById(tourId)                .orElseThrow(() -> new IllegalArgumentException("Tour not found with ID: " + tourId));        FavoriteTour favoriteTour = new FavoriteTour();        favoriteTour.setUser(user);        favoriteTour.setTour(tour);        favoriteTour.setAddedDate(LocalDateTime.now());        FavoriteTour savedFavoriteTour = favoriteTourRepository.save(favoriteTour);        FavoriteTourDTO favoriteTourDTO = new FavoriteTourDTO();        favoriteTourDTO.setId(savedFavoriteTour.getId());        favoriteTourDTO.setUserId(user.getUserId());        favoriteTourDTO.setTourId(tour.getTourId());        favoriteTourDTO.setAddedDate(savedFavoriteTour.getAddedDate());        return favoriteTourDTO;    }    public void removeFavoriteTour(Long userId, Long tourId) {        User user = userRepository.findById(userId)                .orElseThrow(() -> new EntityNotFoundException("User not found for id: " + userId));        Tour tour = tourRepository.findById(tourId)                .orElseThrow(() -> new EntityNotFoundException("Tour not found for id: " + tourId));        FavoriteTour favoriteTour = favoriteTourRepository.findByUserAndTour(user, tour);        if (favoriteTour != null) {            favoriteTourRepository.delete(favoriteTour);        } else {            throw new EntityNotFoundException("Favorite tour not found for userId: " + userId + " and tourId: " + tourId);        }    }    @Override    public Set<Tour> getFavoriteToursByUser(User user) {        return null;    }    @Override    public List<TourListDTO> getFavoriteToursByUserId(Long userId) {        User user = userRepository.findById(userId)                .orElseThrow(() -> new IllegalArgumentException("User not found with ID: " + userId));        List<FavoriteTour> favoriteTours = favoriteTourRepository.findByUser(user);        // Check if favoriteTours is empty        if (favoriteTours.isEmpty()) {            return Collections.emptyList(); // Return an empty list if no favorite tours found        }        LocalDateTime threeDaysFromNow = LocalDateTime.now().plusDays(3);        Set<String> uniqueTours = new HashSet<>();        List<TourListDTO> tourListDTOs = favoriteTours.stream()                .filter(favoriteTour -> {                    Tour tour = favoriteTour.getTour();                    return tour != null && tour.isActive() &&                            tour.getTourType() != TourType.DELETE &&                            !tour.getDepartures().isEmpty() &&                            tour.getDepartures().stream()                                    .anyMatch(departure -> departure.isActive() &&                                            departure.getAvailableSeats() > 0 &&                                            departure.getStartDate().isAfter(threeDaysFromNow));                })                .sorted(Comparator.comparing(FavoriteTour::getAddedDate).reversed())                .map(favoriteTour -> {                    Tour tour = favoriteTour.getTour();                    if (tour == null) return null; // Added null check for tour                    // Create a unique key based on userId and tourId                    String uniqueKey = userId + "-" + tour.getTourId();                    if (uniqueTours.contains(uniqueKey)) {                        return null; // Skip duplicates                    }                    uniqueTours.add(uniqueKey);                    BigDecimal lowestPrice = tour.getDepartures().stream()                            .flatMap(departure -> departure.getTourPricing().stream())                            .map(TourPricing::getPrice)                            .filter(Objects::nonNull)                            .min(BigDecimal::compareTo)                            .orElse(BigDecimal.ZERO);                    return TourListDTO.builder()                            .tourId(tour.getTourId())                            .tourName(tour.getTourName())                            .tourDescription(tour.getTourDescription())                            .price(lowestPrice)                            .duration(tour.getDuration())                            .maxParticipants(tour.getDepartures().stream()                                    .findFirst()                                    .map(Departure::getMaxParticipants)                                    .orElse(null))                            .startLocation(tour.getStartLocation())                            .startDate(tour.getDepartures().stream()                                    .filter(departure -> departure.getStartDate().isAfter(LocalDateTime.now().plusDays(3)))                                    .findAny()                                    .map(Departure::getStartDate)                                    .orElse(null))                            .availableSeats(tour.getDepartures().stream()                                    .findFirst()                                    .map(Departure::getAvailableSeats)                                    .orElse(0))                            .imageUrl(tour.getImages().isEmpty() ? null :                                    tour.getImages().iterator().next().getImageUrl())                            .build();                })                .filter(Objects::nonNull) // Remove nulls from duplicates                .collect(Collectors.toList());        return tourListDTOs;    }}