package vn.edu.iuh.fit.service.implement;import jakarta.persistence.EntityNotFoundException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import vn.edu.iuh.fit.dto.FavoriteTourDTO;import vn.edu.iuh.fit.dto.TourListDTO;import vn.edu.iuh.fit.entity.FavoriteTour;import vn.edu.iuh.fit.entity.Tour;import vn.edu.iuh.fit.entity.User;import vn.edu.iuh.fit.entity.*;import vn.edu.iuh.fit.enums.TourType;import vn.edu.iuh.fit.repositories.FavoriteTourRepository;import vn.edu.iuh.fit.repositories.ReviewRepository;import vn.edu.iuh.fit.repositories.TourRepository;import vn.edu.iuh.fit.repositories.UserRepository;import vn.edu.iuh.fit.service.FavoriteTourService;import java.math.BigDecimal;import java.math.RoundingMode;import java.time.LocalDateTime;import java.util.*;import java.util.stream.Collectors;@Servicepublic class FavoriteTourServiceImpl implements FavoriteTourService {    @Autowired    private FavoriteTourRepository favoriteTourRepository;    @Autowired    private UserRepository userRepository;    @Autowired    private TourRepository tourRepository;@Autowiredprivate ReviewRepository reviewRepository;    @Override    public FavoriteTourDTO addFavoriteTour(Long userId, Long tourId) {        User user = userRepository.findById(userId)                .orElseThrow(() -> new IllegalArgumentException("User not found with ID: " + userId));        Tour tour = tourRepository.findById(tourId)                .orElseThrow(() -> new IllegalArgumentException("Tour not found with ID: " + tourId));        FavoriteTour favoriteTour = new FavoriteTour();        favoriteTour.setUser(user);        favoriteTour.setTour(tour);        favoriteTour.setAddedDate(LocalDateTime.now());        FavoriteTour savedFavoriteTour = favoriteTourRepository.save(favoriteTour);        FavoriteTourDTO favoriteTourDTO = new FavoriteTourDTO();        favoriteTourDTO.setId(savedFavoriteTour.getId());        favoriteTourDTO.setUserId(user.getUserId());        favoriteTourDTO.setTourId(tour.getTourId());        favoriteTourDTO.setAddedDate(savedFavoriteTour.getAddedDate());        return favoriteTourDTO;    }    public void removeFavoriteTour(Long userId, Long tourId) {        User user = userRepository.findById(userId)                .orElseThrow(() -> new EntityNotFoundException("User not found for id: " + userId));        Tour tour = tourRepository.findById(tourId)                .orElseThrow(() -> new EntityNotFoundException("Tour not found for id: " + tourId));        FavoriteTour favoriteTour = favoriteTourRepository.findByUserAndTour(user, tour);        if (favoriteTour != null) {            favoriteTourRepository.delete(favoriteTour);        } else {            throw new EntityNotFoundException("Favorite tour not found for userId: " + userId + " and tourId: " + tourId);        }    }    @Override    public Set<Tour> getFavoriteToursByUser(User user) {        return null;    }    @Override    public List<TourListDTO> getFavoriteToursByUserId(Long userId) {        User user = userRepository.findById(userId)                .orElseThrow(() -> new IllegalArgumentException("User not found with ID: " + userId));        List<FavoriteTour> favoriteTours = favoriteTourRepository.findByUser(user);        // Check if favoriteTours is empty        if (favoriteTours.isEmpty()) {            return Collections.emptyList(); // Return an empty list if no favorite tours found        }        LocalDateTime threeDaysFromNow = LocalDateTime.now().plusDays(3);        Set<String> uniqueTours = new HashSet<>();        List<TourListDTO> tourListDTOs = favoriteTours.stream()                .filter(favoriteTour -> {                    Tour tour = favoriteTour.getTour();                    return tour != null && tour.isActive() &&                            tour.getTourType() != TourType.DELETE &&                            !tour.getDepartures().isEmpty() &&                            tour.getDepartures().stream()                                    .anyMatch(departure -> departure.isActive() &&                                            departure.getAvailableSeats() > 0 &&                                            departure.getStartDate().isAfter(threeDaysFromNow));                })                .sorted(Comparator.comparing(FavoriteTour::getAddedDate).reversed())                .map(favoriteTour -> {                    Tour tour = favoriteTour.getTour();                    if (tour == null) return null; // Added null check for tour                    // Create a unique key based on userId and tourId                    String uniqueKey = userId + "-" + tour.getTourId();                    if (uniqueTours.contains(uniqueKey)) {                        return null; // Skip duplicates                    }                    uniqueTours.add(uniqueKey);                    BigDecimal lowestPrice = tour.getDepartures().stream()                            .flatMap(departure -> departure.getTourPricing().stream())                            .map(TourPricing::getPrice)                            .filter(Objects::nonNull)                            .min(BigDecimal::compareTo)                            .orElse(BigDecimal.ZERO);                    return TourListDTO.builder()                            .tourId(tour.getTourId())                            .tourName(tour.getTourName())                            .tourType(tour.getTourType())                            .tourDescription(tour.getTourDescription())                            .price(lowestPrice)                            .duration(tour.getDuration())                            .maxParticipants(tour.getDepartures().stream()                                    .findFirst()                                    .map(Departure::getMaxParticipants)                                    .orElse(null))                            .startLocation(tour.getStartLocation())                            .startDate(tour.getDepartures().stream()                                    .filter(departure -> departure.getStartDate().isAfter(LocalDateTime.now().plusDays(3)))                                    .findAny()                                    .map(Departure::getStartDate)                                    .orElse(null))                            .availableSeats(tour.getDepartures().stream()                                    .map(Departure::getAvailableSeats)                                    .reduce(0, Integer::sum))                            .imageUrl(tour.getImages().isEmpty() ? null :                                    tour.getImages().iterator().next().getImageUrl())                            .build();                })                .filter(Objects::nonNull)                .collect(Collectors.toList());        return tourListDTOs;    }    @Override    public List<TourListDTO> getAllFavoriteTours() {        List<FavoriteTour> favoriteTours = favoriteTourRepository.findAll();        if (favoriteTours.isEmpty()) {            return Collections.emptyList();        }        // Đếm số lần yêu thích cho mỗi tour        Map<Long, Long> favoriteCountMap = favoriteTours.stream()                .collect(Collectors.groupingBy(favoriteTour -> favoriteTour.getTour().getTourId(), Collectors.counting()));        // Đếm số lượng đánh giá và tính điểm trung bình        Map<Long, Long> reviewCountMap = new HashMap<>();        Map<Long, Double> averageRatingMap = new HashMap<>();        // Giả định bạn có một phương thức lấy tất cả đánh giá        List<Review> allReviews = reviewRepository.findAll();        for (Review review : allReviews) {            Long tourId = review.getTour().getTourId();            reviewCountMap.put(tourId, reviewCountMap.getOrDefault(tourId, 0L) + 1);            averageRatingMap.put(tourId, averageRatingMap.getOrDefault(tourId, 0.0) + review.getRating());        }        // Tính điểm trung bình        // Tính điểm trung bình        for (Map.Entry<Long, Double> entry : averageRatingMap.entrySet()) {            Long tourId = entry.getKey();            Double totalRating = entry.getValue();            Long count = reviewCountMap.get(tourId);            BigDecimal average = BigDecimal.valueOf(totalRating / count)                    .setScale(2, RoundingMode.HALF_UP);            averageRatingMap.put(tourId, average.doubleValue());        }        Set<Long> uniqueTourIds = new HashSet<>();        List<TourListDTO> tourListDTOs = favoriteTours.stream()                .map(favoriteTour -> {                    Tour tour = favoriteTour.getTour();                    if (tour == null || !tour.isActive() || tour.getTourType() == TourType.DELETE) {                        return null;                    }                    // Tránh trùng lặp                    if (uniqueTourIds.contains(tour.getTourId())) {                        return null;                    }                    uniqueTourIds.add(tour.getTourId());                    BigDecimal lowestPrice = tour.getDepartures().stream()                            .flatMap(departure -> departure.getTourPricing().stream())                            .map(TourPricing::getPrice)                            .filter(Objects::nonNull)                            .min(BigDecimal::compareTo)                            .orElse(BigDecimal.ZERO);                    // Tạo TourListDTO với likeCount, reviewCount, và averageRating                    return TourListDTO.builder()                            .tourId(tour.getTourId())                            .tourName(tour.getTourName())                            .tourType(tour.getTourType())                            .tourDescription(tour.getTourDescription())                            .price(lowestPrice)                            .duration(tour.getDuration())                            .maxParticipants(tour.getDepartures().stream()                                    .findFirst()                                    .map(Departure::getMaxParticipants)                                    .orElse(null))                            .startLocation(tour.getStartLocation())                            .startDate(tour.getDepartures().stream()                                    .findAny()                                    .map(Departure::getStartDate)                                    .orElse(null))                            .availableSeats(tour.getDepartures().stream()                                    .map(Departure::getAvailableSeats)                                    .reduce(0, Integer::sum))                            .imageUrl(tour.getImages().isEmpty() ? null :                                    tour.getImages().iterator().next().getImageUrl())                            .likeCount(favoriteCountMap.get(tour.getTourId())) // Số lượt thích                            .reviewCount(reviewCountMap.getOrDefault(tour.getTourId(), 0L)) // Số lượng đánh giá                            .averageRating(averageRatingMap.getOrDefault(tour.getTourId(), 0.0)) // Điểm trung bình                            .build();                })                .filter(Objects::nonNull) // Loại bỏ null                .collect(Collectors.toList());        // Sắp xếp theo số lần yêu thích        tourListDTOs.sort((dto1, dto2) -> {            Long count1 = favoriteCountMap.getOrDefault(dto1.getTourId(), 0L);            Long count2 = favoriteCountMap.getOrDefault(dto2.getTourId(), 0L);            return count2.compareTo(count1); // Sắp xếp giảm dần        });        return tourListDTOs;    }}