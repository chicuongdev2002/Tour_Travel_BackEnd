package vn.edu.iuh.fit.service.token;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import io.jsonwebtoken.io.Decoders;import io.jsonwebtoken.security.Keys;import jakarta.servlet.http.Cookie;import jakarta.servlet.http.HttpServletResponse;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import vn.edu.iuh.fit.entity.Token;import vn.edu.iuh.fit.entity.User;import vn.edu.iuh.fit.repositories.TokenRepository;import java.security.Key;import java.time.Instant;import java.util.Date;import java.util.Optional;import java.util.UUID;@Servicepublic class TokenService {    @Autowired    private TokenRepository tokenRepository;    private static final String SECRET_KEY = "404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970";    private static final long ACCESS_TOKEN_DURATION =  60 * 1000 ; // 30 minutes 30 * 60 * 1000    private static final long REFRESH_TOKEN_DURATION =30L * 24 * 60 * 60 * 1000; // 30 days 30L * 24 * 60 * 60 * 1000    private Key getSigningKey() {        byte[] keyBytes = Decoders.BASE64.decode(SECRET_KEY);        return Keys.hmacShaKeyFor(keyBytes);    }    public String generateToken(User user) {        return Jwts.builder()                .setSubject(user.getEmail())                .claim("userId", user.getUserId())                .claim("fullName",user.getFullName())                .claim("role", user.getAccount().getRole().name())                .setIssuedAt(new Date(System.currentTimeMillis()))                .setExpiration(new Date(System.currentTimeMillis() + ACCESS_TOKEN_DURATION))                .signWith(getSigningKey())                .compact();    }    public String generateRefreshToken() {        return UUID.randomUUID().toString();    }    public Token createToken(User user) {        String jwtToken = generateToken(user);        String refreshToken = generateRefreshToken();        revokeAllUserTokens(user);        Token token = Token.builder()                .user(user)                .token(jwtToken)                .refreshToken(refreshToken)                .tokenExpiry(Instant.now().plusMillis(ACCESS_TOKEN_DURATION))                .refreshTokenExpiry(Instant.now().plusMillis(REFRESH_TOKEN_DURATION))                .expired(false)                .revoked(false)                .build();        return tokenRepository.save(token);    }    public void setRefreshTokenCookie(HttpServletResponse response, String refreshToken) {        Cookie cookie = new Cookie("refresh_token", refreshToken);        cookie.setHttpOnly(true);                // Prevents JavaScript access        cookie.setSecure(true);                  // Requires HTTPS        cookie.setPath("/api/accounts");         // Restrict to your refresh endpoint path        cookie.setMaxAge(5 * 60);               // Match your REFRESH_TOKEN_DURATION        cookie.setDomain("localhost");           // Match your domain        response.addCookie(cookie);    }    public void revokeAllUserTokens(User user) {        var validUserTokens = tokenRepository.findAllValidTokenByUser(user.getUserId());        if (validUserTokens.isEmpty())            return;        validUserTokens.forEach(token -> {            token.setExpired(true);            token.setRevoked(true);        });        tokenRepository.saveAll(validUserTokens);    }    public Optional<Token> findByToken(String token) {        return tokenRepository.findByToken(token);    }    public Optional<Token> findByRefreshToken(String refreshToken) {        return tokenRepository.findByRefreshToken(refreshToken);    }    public Claims validateToken(String token) {        return Jwts.parserBuilder()                .setSigningKey(getSigningKey())                .build()                .parseClaimsJws(token)                .getBody();    }    public Token refreshToken(String refreshToken) {        Optional<Token> tokenOpt = findByRefreshToken(refreshToken);        if (tokenOpt.isEmpty()) {            throw new RuntimeException("Invalid refresh token");        }        Token token = tokenOpt.get();        if (isRefreshTokenExpired(token)) {            throw new RuntimeException("Expired refresh token");        }        String newAccessToken = generateToken(token.getUser());        token.setToken(newAccessToken);        token.setTokenExpiry(Instant.now().plusMillis(ACCESS_TOKEN_DURATION));        return tokenRepository.save(token);    }    private boolean isRefreshTokenExpired(Token token) {        return token.getRefreshTokenExpiry().isBefore(Instant.now());    }}